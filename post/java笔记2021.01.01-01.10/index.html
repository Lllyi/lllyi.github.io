<!doctype html>
<html lang="en-us">
  <head>
    <title> // My New Hugo Site</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.79.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://lllyi.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="2021.01.02   常量-使用final关键字修饰的成员变量。
 代表常数，便于修改 增强程序可读性  Java常量名必须全大写。
  局部变量使用时，必须先初始化；成员变量和静态变量可以不用进行初始化，他会有默认值。
  基本数据类型存储在栈上，变量名指向具体数值；引用数据类型变量名指向存储对象的内存地址，在栈上，内存地址指向的对象存储在堆上。
   2021.01.03   对于一条链表进行分聚操作时，可以考虑设置多条分支，最后整合分支，得到结果。
  **例 leetcode.problems.T86 ** 对一条链表大于x和小于x的节点进行分隔，并保持相对位置
 设置两个头结点 smallHead和largeHead，通过遍历原链表，对应节点插入到新的链表中，最后合并两条链表，得到结果。
⚠️头结点和尾结点的处理，smallHead和largeHead应设置为哑节点，即他们的指针指向链表的头结点，能够更好处理头结点为空的边界条件。
     Integer.toBinaryString()方法，完成十进制到二进制的转化。
     位运算符 作用（针对二进制数）     &amp; 如果对应位都为1，则结果为1，否则为0   | 对应位都是0，则结果为0，否则为1   ^ 异或 对应位值相同，则结果为0，否则为1   ~ 按位去反 二进制数 0变1，1变0   &laquo; 按位左移，左操作数按位左移右操作数指定的位数 8&laquo;1 =16 左移一位相当于×2   &raquo; 按位右移，左操作数按位右移右操作数指定的位数 8&raquo;1 = 4 右移一位相当于/2   &raquo;&gt; 按位右移补零，左操作数的值按右操作数指定的位数右移，移动得到的空位补0    &raquo; 和 &raquo;&gt;的区别：&raquo; 带符号右移。正数右移高位补0，负数右移高位补1。"/>

    <meta property="og:title" content="" />
<meta property="og:description" content="2021.01.02   常量-使用final关键字修饰的成员变量。
 代表常数，便于修改 增强程序可读性  Java常量名必须全大写。
  局部变量使用时，必须先初始化；成员变量和静态变量可以不用进行初始化，他会有默认值。
  基本数据类型存储在栈上，变量名指向具体数值；引用数据类型变量名指向存储对象的内存地址，在栈上，内存地址指向的对象存储在堆上。
   2021.01.03   对于一条链表进行分聚操作时，可以考虑设置多条分支，最后整合分支，得到结果。
  **例 leetcode.problems.T86 ** 对一条链表大于x和小于x的节点进行分隔，并保持相对位置
 设置两个头结点 smallHead和largeHead，通过遍历原链表，对应节点插入到新的链表中，最后合并两条链表，得到结果。
⚠️头结点和尾结点的处理，smallHead和largeHead应设置为哑节点，即他们的指针指向链表的头结点，能够更好处理头结点为空的边界条件。
     Integer.toBinaryString()方法，完成十进制到二进制的转化。
     位运算符 作用（针对二进制数）     &amp; 如果对应位都为1，则结果为1，否则为0   | 对应位都是0，则结果为0，否则为1   ^ 异或 对应位值相同，则结果为0，否则为1   ~ 按位去反 二进制数 0变1，1变0   &laquo; 按位左移，左操作数按位左移右操作数指定的位数 8&laquo;1 =16 左移一位相当于×2   &raquo; 按位右移，左操作数按位右移右操作数指定的位数 8&raquo;1 = 4 右移一位相当于/2   &raquo;&gt; 按位右移补零，左操作数的值按右操作数指定的位数右移，移动得到的空位补0    &raquo; 和 &raquo;&gt;的区别：&raquo; 带符号右移。正数右移高位补0，负数右移高位补1。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lllyi.github.io/post/java%E7%AC%94%E8%AE%B02021.01.01-01.10/" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://lllyi.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>My New Hugo Site</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title"></h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jan 1, 0001
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          5 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <h2 id="20210102">2021.01.02</h2>
<ol>
<li>
<p>常量-使用final关键字修饰的成员变量。</p>
<ul>
<li>代表常数，便于修改</li>
<li>增强程序可读性</li>
</ul>
<p>Java常量名必须全大写。</p>
</li>
<li>
<p>局部变量使用时，必须先初始化；成员变量和静态变量可以不用进行初始化，他会有默认值。</p>
</li>
<li>
<p>基本数据类型存储在栈上，变量名指向具体数值；引用数据类型变量名指向存储对象的内存地址，在栈上，内存地址指向的对象存储在堆上。</p>
</li>
</ol>
<hr>
<h2 id="20210103">2021.01.03</h2>
<ol>
<li>
<p>对于一条链表进行分聚操作时，可以考虑设置多条分支，最后整合分支，得到结果。</p>
<ul>
<li>
<p>**例 leetcode.problems.T86 ** 对一条链表大于x和小于x的节点进行分隔，并保持相对位置</p>
<blockquote>
<p>设置两个头结点 smallHead和largeHead，通过遍历原链表，对应节点插入到新的链表中，最后合并两条链表，得到结果。</p>
<p>⚠️头结点和尾结点的处理，smallHead和largeHead应设置为<strong>哑节点</strong>，即他们的指针指向链表的头结点，能够更好处理头结点为空的边界条件。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Integer.toBinaryString()方法，完成十进制到二进制的转化。</p>
</li>
<li>
<table>
<thead>
<tr>
<th>位运算符</th>
<th>作用（针对二进制数）</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>如果对应位都为1，则结果为1，否则为0</td>
</tr>
<tr>
<td>|</td>
<td>对应位都是0，则结果为0，否则为1</td>
</tr>
<tr>
<td>^    异或</td>
<td>对应位值相同，则结果为0，否则为1</td>
</tr>
<tr>
<td>~    按位去反</td>
<td>二进制数 0变1，1变0</td>
</tr>
<tr>
<td>&laquo;</td>
<td>按位左移，左操作数按位左移右操作数指定的位数  8&laquo;1 =16 左移一位相当于×2</td>
</tr>
<tr>
<td>&raquo;</td>
<td>按位右移，左操作数按位右移右操作数指定的位数  8&raquo;1 = 4 右移一位相当于/2</td>
</tr>
<tr>
<td>&raquo;&gt;</td>
<td>按位右移补零，左操作数的值按右操作数指定的位数右移，移动得到的空位补0</td>
</tr>
</tbody>
</table>
<p><em>&raquo;</em> 和 &raquo;&gt;的区别：&raquo;   带符号右移。正数右移高位补0，负数右移高位补1。</p>
<p>​							  &raquo;&gt;  无符号右移。无论正数负数，高位补0。</p>
<ul>
<li>对于正数而言，&raquo;和&raquo;&gt;，没有区别；对于负数而言，-2&raquo;&gt;1=214748347(Integer.MAX_VALUE),-1&raquo;&gt;1=2147483647(Integer.MAX_VALUE)</li>
</ul>
</li>
<li>
<p>m&raquo;n表示m/(2^n)  ; m&laquo;n表示m*(2^n)</p>
</li>
<li>
<p>&amp;和|不管第一个条件true or false 都会检查第二个，很少用，性能不如&amp;&amp;和||，用法相同。</p>
</li>
<li>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//赋值问题
</span><span style="color:#75715e"></span><span style="color:#66d9ef">short</span> a <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span>
<span style="color:#66d9ef">short</span> b <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span>
a <span style="color:#f92672">=</span> a<span style="color:#f92672">+</span>b<span style="color:#f92672">;</span><span style="color:#75715e">//error, short两个字节，-2^15~2^15-1，在范围内。但是=右侧的算术表达式默认为int类型，左侧是short类型时需要进行强转。 a = (short)(a+b);
</span><span style="color:#75715e">//边界问题，两个大的int想乘，结果可能超过了int的范围。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> 100<span style="color:#f92672">;</span>
<span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> a<span style="color:#f92672">*</span>b<span style="color:#f92672">;</span><span style="color:#75715e">//超出了int范围，可以通过右侧强转long long c = (long)a*b; 不建议。 当结果非常大时，尽量提前使用相应的类型进行赋值。long a,b,c;
</span></code></pre></div></li>
<li>
<p>命名规则</p>
<blockquote>
<p>1、包（package）</p>
<blockquote>
<ul>
<li>小写字母</li>
<li>分隔符之间有且仅有一个自然语义的英文单词</li>
<li>包名统一使用单数形式，如com.llly.util 不能是com.llly.utiles</li>
<li>包名前加上唯一的前缀，由于互联网上的域名不会重复，一般采用个人博客在互联网上的域名作为包的前缀</li>
</ul>
</blockquote>
<p>2、类（class）</p>
<blockquote>
<ul>
<li>必须以大写字母开头</li>
<li>最好是一个名词</li>
<li>类名使用UpperCamelCase（驼峰式命名）风格</li>
<li>尽量不用省略成单词的首字母</li>
<li>如果是抽象类，使用Abstract或Base开头；如果是异常类，使用Exception结尾；如果是测试类，使用Test结尾</li>
</ul>
</blockquote>
<p>3、接口（interface）</p>
<blockquote>
<ul>
<li>
<p>必须以大写字母开头</p>
</li>
<li>
<p>最好是一个形容词，如Runnable</p>
</li>
<li>
<p>尽量不要省略成单吃的首字母</p>
<p>eg:<code>inteterface Printable{}</code></p>
</li>
<li>
<p>实现类用Impl的后缀与接口区别，如CacheServiceImpl实现CacheService接口或AbstractTranslator实现Translatable</p>
</li>
</ul>
</blockquote>
<p>4、字段（field）和变量（variable）</p>
<blockquote>
<ul>
<li>必须以小写字母开头</li>
<li>可以包含多个单词，第一个单词的首字母小写，其他的单词首字母大写，如firstName</li>
<li>最好不要使用单个字符，如int a 除非是局部变量</li>
<li>类型与中括号紧挨项链来表示数组，如int[] arrayDemo</li>
<li>POJO类中的任何布尔类型的变量都不要加is前缀，否则部分框架解析会引起序列化错误。</li>
<li>避免采用完全相同的命名</li>
</ul>
</blockquote>
<p>5、常量（constant）</p>
<blockquote>
<ul>
<li>应该全是大写字母</li>
<li>可包含多个单词，用_连接</li>
</ul>
</blockquote>
<p>6、方法（method）</p>
<blockquote>
<ul>
<li>以小写字母开头</li>
<li>最好是一个动词 如print（）</li>
<li>可包含多个单词，第一个单词首字母小写，其他首字母大写，如actionPerformed（）</li>
</ul>
</blockquote>
</blockquote>
</li>
<li>
<p>缓存池</p>
<blockquote>
<p>new Integer(123)与Interger.valueOf(123)的区别：</p>
<ul>
<li>
<p>new Integer(123)每次都会新建一个对象</p>
</li>
<li>
<p>Integer.valueOf(123)会使用缓存池中的对象，多次调用会取得同一个对象的引用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Integer x <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>123<span style="color:#f92672">);</span>
Integer y <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>123<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>x<span style="color:#f92672">==</span>y<span style="color:#f92672">);</span><span style="color:#75715e">//fasle
</span><span style="color:#75715e"></span>Integer z <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span>123<span style="color:#f92672">);</span>
Integer k <span style="color:#f92672">=</span> Integer<span style="color:#f92672">,</span>valueOf<span style="color:#f92672">(</span>123<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>z<span style="color:#f92672">==</span>k<span style="color:#f92672">);</span><span style="color:#75715e">//true
</span></code></pre></div></li>
<li>
<p>valueOf()方法的实现比较简单，判断值是否在缓存池中，如果在，返回缓存池中的内容。Java8中，Integer缓存池的大小默认为-128~127。编译器会在自动装箱过程中调用valueOf()方法，一次多个值相同且值在缓存池范围内的Integer实例使用自动装箱来创建，则会引用相同的对象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Integer m <span style="color:#f92672">=</span> 123<span style="color:#f92672">;</span>
Integer n <span style="color:#f92672">=</span> 123<span style="color:#f92672">;</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>m<span style="color:#f92672">==</span>n<span style="color:#f92672">);</span><span style="color:#75715e">//true
</span></code></pre></div><blockquote>
<p>基本类型对应缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>Int values between -128 and 127</li>
<li>Char in the range \u0000 to \u007f</li>
</ul>
<p>在使用这些基本类型对应的包装类时，若改数值范围在缓冲池范围内，可以直接使用缓冲池中对象。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<hr>
<h2 id="20210104">2021.01.04</h2>
<ol>
<li>
<p>String类被声明为final，因此他不可被继承（Integer等包装类也不能被继承），不能被修改，可以缓存hash值，可以在String Pool中取得引用。</p>
</li>
<li>
<p>String, StringBuffer, StringBuilder的异同</p>
<ul>
<li>String不可变，StringBuffer和StringBuilder都是可变的</li>
<li>StringBuilder不是线程安全的，应用于单线程程序；StringBuffer是线程安全的，内部使用Synchronized进行同步</li>
</ul>
</li>
<li>
<p>String Pool（字符串常量池）保留着所有字符串的字面量，在编译时期就确定了。</p>
<ul>
<li>
<p>String的intern()方法在运行过程将字符串添加到StringPool中，当字符串调用intern()方法时，若StringPool中已经存在一个字符串和该字符串值相等（使用equal方法确定），则返回StringPool中字符串的引用；否则，在StringPool中添加一个新的字符串，并返回这个新字符串的引用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String s1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;aaa&#34;</span><span style="color:#f92672">);</span>
String s2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;aaa&#34;</span><span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>s1<span style="color:#f92672">==</span>s2<span style="color:#f92672">);</span><span style="color:#75715e">//false
</span><span style="color:#75715e"></span>String s3 <span style="color:#f92672">=</span> s1<span style="color:#f92672">.</span><span style="color:#a6e22e">intern</span><span style="color:#f92672">();</span>
String s4 <span style="color:#f92672">=</span> s2<span style="color:#f92672">.</span><span style="color:#a6e22e">intern</span><span style="color:#f92672">();</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>s3<span style="color:#f92672">==</span>s4<span style="color:#f92672">);</span><span style="color:#75715e">//true
</span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h3 id="20210105">2021.01.05</h3>
<ol>
<li>
<p>Java不能隐式执行向下转型，因为会使精度降低。</p>
<ul>
<li>
<p>1.1字面量属于double类型，不能直接将1.1赋值给float变量，因为这是向下转型。</p>
<p><code> float f = 1.1f//需要＋f实现向下转型</code></p>
</li>
</ul>
</li>
<li>
<p>隐式类型转换</p>
<ul>
<li>
<p>字面量1是int型，比short精度高，不能隐式将int向下转型为short类型。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">short</span> s <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
s <span style="color:#f92672">=</span> s<span style="color:#f92672">+</span>1<span style="color:#f92672">;</span><span style="color:#75715e">//error  1为int型，此处改为s = (short)(s+1);
</span></code></pre></div><p>但是使用+=或++运算符会执行隐式类型转换。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">s <span style="color:#f92672">+=</span> 1<span style="color:#f92672">;</span><span style="color:#75715e">//true
</span><span style="color:#75715e"></span>s<span style="color:#f92672">++;</span><span style="color:#75715e">//true   相当于 s=(short)(s+1);
</span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>final</strong></p>
<ul>
<li>
<p>数据</p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<blockquote>
<p>对于基本类型，final使数值不变</p>
<p>对于引用类型，final使引用不变，也就不能引用其他对象，但被引用对象本身是可修改的</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
x <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span><span style="color:#75715e">//error cannot assign value to final variable &#39;x&#39;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> A y <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> A<span style="color:#f92672">();</span>
y<span style="color:#f92672">.</span><span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
</code></pre></div></li>
<li>
<p>方法</p>
<p>声明的方法不能被子类重写。 private方法隐式地被指定为final，如果子类中定义的方法和基类中的一个private方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>
</li>
<li>
<p>类</p>
<p>final声明的类不能被继承。</p>
</li>
</ul>
</li>
<li>
<p><strong>static</strong></p>
<ul>
<li>
<p>静态变量</p>
<blockquote>
<p>静态变量：又称类变量，类的所有实例都共享静态变量，可以通过类名访问他，在内存中只存在一份。</p>
<p>实例变量：每创建一个实例就会产生一个实例变量。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span><span style="color:#f92672">{</span>
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span><span style="color:#75715e">//实例变量
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">;</span><span style="color:#75715e">//静态变量
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>静态方法</p>
<blockquote>
<p>静态方法在类加载时就已经存在，不依赖任何实例。所以静态方法必须有实现，不能是抽象方法。</p>
<p>只能访问<strong>所属类的静态字段和静态方法</strong>，方法中不能有this和super，因为这俩关键字与具体对象关联。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span><span style="color:#f92672">{</span>
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func1</span><span style="color:#f92672">(){</span>
    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> y<span style="color:#f92672">;</span><span style="color:#75715e">//error 
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">y</span><span style="color:#f92672">;</span><span style="color:#75715e">//error
</span><span style="color:#75715e"></span>  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>静态语句块</p>
<p>静态语句块在类初始化时运行一次。</p>
</li>
<li>
<p>静态内部类</p>
<p><strong>非静态内部类依赖于外部类的实例</strong>，也就是说需要先创建外部类实例，才能用这个实例创建非静态内部类，<strong>而静态内部类不需要。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OuterClass</span><span style="color:#f92672">{</span>
  <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InnerClass</span><span style="color:#f92672">{</span>
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StaticInnerClass</span><span style="color:#f92672">{</span>
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">){</span>
    InnerClass inner <span style="color:#f92672">=</span>  <span style="color:#66d9ef">new</span> InnerClass<span style="color:#f92672">();</span><span style="color:#75715e">//error
</span><span style="color:#75715e"></span>    StaticInnerClass staticinner <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StaticInnerClass<span style="color:#f92672">();</span><span style="color:#75715e">//true
</span><span style="color:#75715e"></span>    OuterClass outer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OuterClass<span style="color:#f92672">();</span>
    InnerClass inner <span style="color:#f92672">=</span> outer<span style="color:#f92672">.</span><span style="color:#a6e22e">new</span> <span style="color:#a6e22e">InnerClass</span><span style="color:#f92672">();</span><span style="color:#75715e">//true
</span><span style="color:#75715e"></span>  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>静态导包</p>
</li>
<li>
<p><strong>初始化顺序</strong></p>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于他们在代码中的顺序。这些完成之后最后才是构造函数的初始化。</p>
<blockquote>
<p>存在继承情况下的初始化顺序：</p>
<ul>
<li>父类（静态变量，静态语句块）</li>
<li>子类（静态变量，静态语句块）</li>
<li>父类（实例变量，普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量，普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>equals()</strong></p>
<ul>
<li>
<p>等价关系，五个条件。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>x<span style="color:#f92672">);</span><span style="color:#75715e">// true， 自反性
</span><span style="color:#75715e"></span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>y<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> y<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>x<span style="color:#f92672">);</span><span style="color:#75715e">// true, 对称性
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>y<span style="color:#f92672">)&amp;&amp;</span>y<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>z<span style="color:#f92672">))</span>
  x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>z<span style="color:#f92672">);</span><span style="color:#75715e">//true， 传递性
</span><span style="color:#75715e"></span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>y<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>y<span style="color:#f92672">);</span><span style="color:#75715e">//true, 一致性，多次调用equals方法结果不变。
</span><span style="color:#75715e"></span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">);</span><span style="color:#75715e">//false 与null比较 对于任何不是null的对象x调用x.equals(null)，结果为false
</span></code></pre></div></li>
<li>
<p><strong>实现</strong></p>
<blockquote>
<ul>
<li>
<p>检查是否为同一个对象的引用，如果是返回true；</p>
</li>
<li>
<p>检查是否为同一个类型，如果不适，返回false；</p>
</li>
<li>
<p>将<strong>Object对象进行转型</strong>；</p>
</li>
<li>
<p>判断每个关键域是否相等。</p>
</li>
</ul>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EqualExample</span> <span style="color:#f92672">{</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span> 
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> z<span style="color:#f92672">;</span>
   <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">EqualExample</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> z<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span> 
  <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> y<span style="color:#f92672">;</span> 
  <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> z<span style="color:#f92672">;</span> 
   <span style="color:#f92672">}</span>
  <span style="color:#a6e22e">@override</span>
   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object o<span style="color:#f92672">){</span>
   <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> o<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
   <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>o <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">||</span>getClass<span style="color:#f92672">()!=</span>o<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">())</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
       
   EqualExample that <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>EqualExample<span style="color:#f92672">)</span> o<span style="color:#f92672">;</span><span style="color:#75715e">//将Object对象进行转型
</span><span style="color:#75715e"></span>       
   <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>x<span style="color:#f92672">!=</span>that<span style="color:#f92672">.</span><span style="color:#a6e22e">x</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>y<span style="color:#f92672">!=</span>that<span style="color:#f92672">.</span><span style="color:#a6e22e">y</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> z<span style="color:#f92672">==</span>that<span style="color:#f92672">.</span><span style="color:#a6e22e">z</span><span style="color:#f92672">;</span>
   <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><strong>hashCode()</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">EqualExample e1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> EqualExample<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span>1<span style="color:#f92672">,</span>1<span style="color:#f92672">);</span>
EqualExample e2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> EqualExample<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span>1<span style="color:#f92672">,</span>1<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>e1<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>e2<span style="color:#f92672">));</span><span style="color:#75715e">//true;
</span><span style="color:#75715e"></span>HashSet<span style="color:#f92672">&lt;</span>EqualExample<span style="color:#f92672">&gt;</span> set <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;&gt;();</span>
set<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>e1<span style="color:#f92672">);</span>
set<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>e2<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>set<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">());</span><span style="color:#75715e">//2
</span></code></pre></div><p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。</p>
</li>
<li>
<p>toString()</p>
<p>默认返回ToStringExample@4554617c这种形式，其中@后面的数值为散列码的无符号十六进制表示。</p>
</li>
<li>
<p><strong>clone()</strong></p>
<p>clone（）是Object的protected方法，它不是public，一个类不显式去重写clone（），其他类就不能直接去调用该类实例的clone（）方法。</p>
<ul>
<li>
<p><strong>浅拷贝</strong>：拷贝对象和原始对象的引用类型引用同一个对象，即指向同一地址。当两者之一发生改变时，另一个跟着变。代码见base_github.ShallowCloneExample</p>
</li>
<li>
<p><strong>深拷贝</strong>：拷贝对象和原始对象的引用类型引用不同对象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Override</span>
<span style="color:#66d9ef">protected</span> DeepCloneExample <span style="color:#a6e22e">clone</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> CloneNotSupportedException<span style="color:#f92672">{</span>
  <span style="color:#75715e">//浅克隆 ： return (DeepCloneExample) super.clone();
</span><span style="color:#75715e"></span>  DeepCloneExample result <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>DeepCloneExample<span style="color:#f92672">)</span> <span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">clone</span><span style="color:#f92672">();</span>
  result<span style="color:#f92672">.</span><span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span><span style="color:#75715e">//这里重新申请一个新数组，存放原先的值。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span> i<span style="color:#f92672">&lt;</span>arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++){</span>
    result<span style="color:#f92672">.</span><span style="color:#a6e22e">arr</span><span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p><strong>clone（）的替代方案</strong></p>
<p>使用clone()方法既复杂又有风险，会抛出异常，还需要类型转换。Effective Java书上讲：最好不用clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。即<strong>利用多态构造函数，完成对原数据的克隆</strong>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">CloneConstructorExample</span><span style="color:#f92672">(</span>CloneConstructorExample original<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> 
  arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>original<span style="color:#f92672">.</span><span style="color:#a6e22e">arr</span><span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span> 
  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> original<span style="color:#f92672">.</span><span style="color:#a6e22e">arr</span><span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span> 
    arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> original<span style="color:#f92672">.</span><span style="color:#a6e22e">arr</span><span style="color:#f92672">[</span>i<span style="color:#f92672">];</span> 
  <span style="color:#f92672">}</span> 
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>||和&amp;&amp;左右项的放置位置很关键，因为它判断第一符合条件或者不符合 条件时就可以略过后一个条件，可以避免内存溢出。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span> i<span style="color:#f92672">&lt;</span>c<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> <span style="color:#f92672">++</span>i<span style="color:#f92672">){</span>
  <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>c<span style="color:#f92672">[</span>i<span style="color:#f92672">]==</span>c<span style="color:#f92672">[</span>i<span style="color:#f92672">+</span>1<span style="color:#f92672">]||</span>i<span style="color:#f92672">==</span>c<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">-</span>1<span style="color:#f92672">)</span>
    <span style="color:#f92672">...</span><span style="color:#75715e">//发生内存溢出，因为i+1
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>i<span style="color:#f92672">==</span>c<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">-</span>1<span style="color:#f92672">||</span>c<span style="color:#f92672">[</span>i<span style="color:#f92672">]=</span>c<span style="color:#f92672">[</span>i<span style="color:#f92672">+</span>1<span style="color:#f92672">])</span>
         <span style="color:#f92672">...</span><span style="color:#75715e">//不溢出，因为在前已经截胡。
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p><strong>继承</strong></p>
<ul>
<li>
<p>访问权限</p>
<ul>
<li>
<p>java中有三个访问权限修饰符：public , protected 以及private，如果不加修饰符，包时包级可见。</p>
</li>
<li>
<p>protected用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>
</li>
<li>
<p>子类的访问权限不能低于父类。</p>
</li>
</ul>
</li>
<li>
<p>抽象类与接口</p>
<ol>
<li>抽象类和抽象方法：用abstract声明，如果类中包含抽象方法，则必须声明为抽象类。抽象类和普通类最大的区别在于抽象类不能被实例化，只能被继承。</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>一个类实现接口和继承抽象类必须实现全部的方法？<strong>如果子类是非抽象类，则必须实现</strong>接口中全部方法</strong>；是抽象类，则不必。
3. 接口是抽象类的延伸，Java8之前不能有任何的方法实现，Java8开始，接口可以拥有默认的方法实现。接口的字段默认都是static和final。</p>
</li>
</ol>
<hr>
<h2 id="20210106">2021.01.06</h2>
<h4 id="1super">1.super</h4>
<ul>
<li>
<p>子类调用父类的构造函数。子类一定需要调用父类的构造函数来完成初始化，一般是调用父类默认的构造函数，如果需要调用父类其他构造函数，那就可以使用super函数。</p>
</li>
<li>
<p>访问父类的成员，通过使用super关键字来引用父类的方法实现。</p>
<blockquote>
<p>this（）：调用本类中其他重载的构造函数</p>
<p>super()：调用父类中的构造函数</p>
</blockquote>
<p>this和super都必须写在函数的第一行，他们不能存在于同一个构造函数中。</p>
<blockquote>
<p>This.xxx():调用本类中重写的父类方法</p>
<p>super.xx()：调用父类中的方法</p>
</blockquote>
<p>他们可以存在同一个构造方法中</p>
</li>
</ul>
<h4 id="2重写与重载">2.重写与重载</h4>
<ul>
<li>子类方法的访问权限需要大于等于父类方法</li>
<li>子类方法的返回类型必须是父类返回类型或子类</li>
<li>子类方法抛出的异常必须是父类抛出异常类型或子类</li>
</ul>
<p>使用@override注解，可以让编译器帮忙检查是否满足以上三个条件。在调用一个方法时，先从本类中找看是否有对应的方法，如果没有再到父类中查看，看是否从父类中继承来，否则就要对参数进行转型，转成父类之后看是否有对应方法。优先级：</p>
<blockquote>
<ul>
<li>this.func(this)</li>
<li>Super.func(this)</li>
<li>This.func(super)</li>
<li>Super.func(super)</li>
</ul>
</blockquote>
<p><strong>重载</strong>：在同一类中，一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。<strong>返回值不算</strong></p>
<h4 id="3-反射">3. 反射</h4>
<p>每个类都有一个<strong>class</strong>对象，包含了与类相关的信息。当编译一个新类时，会产生一个同名的.class文件，该文件内容保存着class对象。						<strong>不懂</strong></p>
<h4 id="4异常">4.异常</h4>
<p>Throwable可以用来表示任何可以作为异常抛出的类，分为两种，<strong>Error</strong>和<strong>Exception</strong>。其中Error用来表示JVM无法处理的错误，Exception分为两种：</p>
<ul>
<li><strong>受检异常</strong>；需要try&hellip;catch..语句捕获并进行处理，且可以从异常中恢复；</li>
<li><strong>非受检异常</strong>：是程序进行时错误，例如除0会引发Arithmetic Exception，此时程序崩溃且无法恢复。</li>
</ul>
<h4 id="5泛型">5.泛型</h4>
<p>泛型，即“参数化类型”，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。<strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Box</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span><span style="color:#75715e">//泛型类
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// T stands for &#34;Type&#34; 
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">private</span> T t<span style="color:#f92672">;</span> 
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>T t<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> 
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">t</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">;</span> 
  <span style="color:#f92672">}</span> 
  <span style="color:#66d9ef">public</span> T <span style="color:#a6e22e">get</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> 
    <span style="color:#66d9ef">return</span> t<span style="color:#f92672">;</span> 
  <span style="color:#f92672">}</span> 
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="6注解">6.注解</h4>
<p>Java 注解是附加在代码中的⼀些元信息，⽤于⼀些⼯具在编译、运⾏时进⾏解析和使⽤，起到说明、配 置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作⽤。</p>
<h3 id="java容器">Java容器</h3>
<ol>
<li>
<p>概览</p>
<blockquote>
<p>容器主要包括Collection和Map两种，Collection存储对象的集合，而Map存储着键值对（两个对象）的映射表。</p>
</blockquote>
<p><strong>Collection</strong></p>
<p><img src="/Users/mwhua/Desktop/Snip20210106_1.png" alt="Snip20210106_1"></p>
<ol>
<li>
<p><strong>Set</strong></p>
<ul>
<li>TreeSet：基于<strong>红黑树</strong>实现，支持<strong>有序操作</strong>，例如根据一个范围查找元素的操作。但是查找效率不如HashSet，HashSet查找时间复杂度为O(1)，TreeSet则为O（logN）。</li>
<li>HashSet：基于<strong>哈希表</strong>实现，⽀持快速查找，但<strong>不⽀持有序性操作</strong>。并且失去<strong>了元素的插⼊顺序信息</strong>，也就是说使⽤ Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有HashSet的查找效率，并且内部使用<strong>双向链表</strong>维护元素的插入顺序。</li>
</ul>
</li>
<li>
<p><strong>List</strong></p>
<ul>
<li>ArrayList：基于<strong>动态数组</strong>实现，支持<strong>随机</strong>访问。</li>
<li>vector：和ArrayList类似，但他是线程安全的。</li>
<li>LinkedList：基于<strong>双向链表</strong>实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素，可以用作栈、队列和双向队列。</li>
</ul>
</li>
<li>
<p><strong>Queue</strong></p>
<ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于<strong>堆结构</strong>实现，可以用它来实现优先队列。</li>
</ul>
</li>
<li>
<p><strong>Map</strong></p>
<p><img src="/Users/mwhua/Desktop/Snip20210106_2.png" alt="Snip20210106_2"></p>
<ul>
<li>TreeMap：基于红黑树实现。</li>
<li>HashMap：基于哈希表实现。</li>
<li>HashTable：和HashMap类似，但他是线程安全的，意味着同一时刻多个线程同时写入。HashTable不会导致数据不一致，它是遗留类，不应该去使⽤它，⽽是使⽤ <strong>ConcurrentHashMap</strong> 来⽀持线程安全，ConcurrentHashMap 的效率会更⾼，因为 ConcurrentHashMap 引⼊了分段锁。</li>
<li>LinkedHashMap：使⽤双向链表来维护元素的顺序，顺序为插⼊顺序或者最近最少使⽤（LRU）顺 序。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="20210107">2021.01.07</h2>
<ol>
<li>
<p>Arrays 包含一系列处理数组的静态方法，可以直接把数组转为列表形式，Arrays.asList()；⚠️asList()的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//传递基本类型的数组，生成List的元素个数为1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> arrc <span style="color:#f92672">=</span> <span style="color:#f92672">{</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#39;b&#39;</span><span style="color:#f92672">};</span>  
<span style="color:#66d9ef">int</span>  arrint <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>1<span style="color:#f92672">,</span>2<span style="color:#f92672">,</span>4<span style="color:#f92672">}</span><span style="color:#960050;background-color:#1e0010">；</span>  
Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>arrc<span style="color:#f92672">).</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">;</span><span style="color:#75715e">//  结果为1；  
</span><span style="color:#75715e"></span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>arrint <span style="color:#f92672">).</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">;</span><span style="color:#75715e">//结果为1；  
</span><span style="color:#75715e"></span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>1<span style="color:#f92672">,</span>2<span style="color:#f92672">,</span>4<span style="color:#f92672">).</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span><span style="color:#75715e">//3
</span><span style="color:#75715e">//传递对象数组，元素个数正确。
</span><span style="color:#75715e"></span>String arrstr <span style="color:#f92672">=</span> <span style="color:#f92672">{</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;java&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;spring&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;hadoop&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;lucene&#34;</span><span style="color:#f92672">};</span>  
Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>arrstr <span style="color:#f92672">).</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">;</span><span style="color:#75715e">//结果为6；  
</span></code></pre></div><p>如果直接传递数字，基本类型数组将被视为一个对象而不会被解析成数组，如果直接传递参数将能正常解析。因此<strong>传递基本类型数组时强烈建议转为其封装类对象的数组 int-&gt;Integer,long-&gt;Long&hellip;</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> List<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>T<span style="color:#f92672">...</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> 
<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;(</span>a<span style="color:#f92672">);</span> 
<span style="color:#f92672">}</span>
</code></pre></div><p>这个T必须是对象类型，如同new ArrayList<!-- raw HTML omitted --></p>
</li>
<li>
<p>transient关键字声明数组默认不会被序列化。</p>
</li>
<li>
<p>Java中Queue是一个接口，使用队列时，一般采用LinkedList。因为LinkedList是双向链表，可以很方便实现队列的所有功能。</p>
<blockquote>
<ul>
<li>Queue使用时要尽量避免Collection的add()和remove()方法，而是要使用offer()来加入元素，使用poll()来获取并移出元素。它们的优点是通过返回值可以判断成功与否，add()和remove()方法在失败的时候会抛出异常。</li>
<li>如果要使用前端而不移出该元素，使用element()或者peek()方法。</li>
</ul>
<table>
<thead>
<tr>
<th>队列方法</th>
<th>等效方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>offer(e)</td>
<td>offer(e)/offerLast(e)</td>
<td>将元素加入队尾</td>
</tr>
<tr>
<td>poll()</td>
<td>Poll()/pollFirst()</td>
<td>返回队头并删除</td>
</tr>
<tr>
<td>peek()</td>
<td>Peek()/peekFirst()</td>
<td>获取队头元素</td>
</tr>
<tr>
<td>isEmpty()</td>
<td></td>
<td>判空</td>
</tr>
</tbody>
</table>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="20210108">2021.01.08</h2>
<ol>
<li>
<p>Stack继承自Vector类，Vector类线程安全，Deque接口和他的实现是一个更完善的LIFO栈操作类。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Deque<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> deque <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayDeque<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;();</span>
</code></pre></div></li>
<li>
<p><strong>PriorityQueue 优先队列</strong></p>
<ul>
<li>例见priorityqueue.PriorityQueueExample</li>
</ul>
<blockquote>
<p>优先队列实际上就是一个堆。</p>
<p>优先队列内部元素的排序可以是自然顺序，也可以是重写Comparator后指定的顺序。两种方法实现指定顺序，①构造priorityQueue时，new Comparator ；②构造PriorityQueue时，传入Comparator。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//①    k为构建的优先队列的容量
</span><span style="color:#75715e"></span>PriorityQueue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> maxheap <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> PriorityQueue<span style="color:#f92672">&lt;&gt;(</span>k<span style="color:#f92672">,</span><span style="color:#66d9ef">new</span> Comparator<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;(){</span>
 <span style="color:#a6e22e">@Override</span>
 <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>Integer o1<span style="color:#f92672">,</span> Integer o2<span style="color:#f92672">){</span>
   <span style="color:#66d9ef">return</span> o2<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>o1<span style="color:#f92672">);</span><span style="color:#75715e">//由大到小排，队头即堆顶为最大值，也就是最小元素。默认是o1.compare(o2)
</span><span style="color:#75715e"></span> <span style="color:#f92672">}</span>
<span style="color:#f92672">})</span>
<span style="color:#75715e">//②  创建一个Comparator类的静态实例，重写实例中的compare方法，此处泛型为person，人为的规定一个比较大小的方式，返回的规则为由小到大。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Comparator<span style="color:#f92672">&lt;</span>person<span style="color:#f92672">&gt;</span> cperson <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Comparator<span style="color:#f92672">&lt;</span>person<span style="color:#f92672">&gt;()</span> <span style="color:#f92672">{</span>
       <span style="color:#a6e22e">@Override</span>
       <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>person o1<span style="color:#f92672">,</span> person o2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
           <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>o1<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> o2<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">()){</span>
               <span style="color:#66d9ef">return</span> o1<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">()</span> <span style="color:#f92672">-</span> o2<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">();</span>
           <span style="color:#f92672">}</span>
           <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>o1<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> o2<span style="color:#f92672">.</span><span style="color:#a6e22e">getAge</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span> o1<span style="color:#f92672">.</span><span style="color:#a6e22e">getTall</span><span style="color:#f92672">()!=</span>o2<span style="color:#f92672">.</span><span style="color:#a6e22e">getTall</span><span style="color:#f92672">()){</span>
               <span style="color:#66d9ef">return</span> o1<span style="color:#f92672">.</span><span style="color:#a6e22e">getTall</span><span style="color:#f92672">()</span> <span style="color:#f92672">-</span> o2<span style="color:#f92672">.</span><span style="color:#a6e22e">getTall</span><span style="color:#f92672">();</span>
           <span style="color:#f92672">}</span>
           <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
               <span style="color:#66d9ef">return</span> o1<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">().</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()</span> <span style="color:#f92672">-</span> o2<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">().</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span>
           <span style="color:#f92672">}</span>

       <span style="color:#f92672">}</span>
   <span style="color:#f92672">};</span>
<span style="color:#75715e">//在创建优先队列实例时传入比较器实例，完成比较顺序的自定义。
</span><span style="color:#75715e"></span>Queue<span style="color:#f92672">&lt;</span>Person<span style="color:#f92672">&gt;</span> queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> PriorityQueue<span style="color:#f92672">&lt;&gt;(</span>k<span style="color:#f92672">,</span>cperson<span style="color:#f92672">);</span>
</code></pre></div></blockquote>
</li>
<li>
<p>Iterator接口，由各个Collection类实现。</p>
<p>Iterator和enumeration接口的两大区别：</p>
<ul>
<li>Iterator允许调用者来移除集合中存在的元素，当Iterator被定义好时。</li>
<li>方法的名称已经得到改进。</li>
</ul>
<blockquote>
<ul>
<li>
<p>在类实现Iterator接口时，完成了hasNext() , next(), remove()方法的重写。</p>
</li>
<li>
<p>hasNext() 返回Boolean类型，判断迭代器是否还有元素。In other words, returns <code>true</code> if next() would return an element rather than throwing an exception.</p>
</li>
<li>
<p>next() 方法返回在迭代器中的下一元素，如果没有元素了 会 throws NoSuchElementException异常。</p>
</li>
<li>
<p>remove()方法，移除集合中存在的由迭代器返回的最后一个元素，这个方法只有在调用每一next方法时才能被调用**？？？** 如果在迭代进行过程中以其他方式（而不是通过调用此方法）修改了基础集合，则未指定迭代器的行为。返回值：void</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<hr>
<h2 id="20210109">2021.01.09</h2>
<ol>
<li>
<p><strong>回溯算法与深度优先搜索DFS</strong></p>
<p>回溯法： 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。</p>
<p>深度优先搜索 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 尽可能深 的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。</p>
<blockquote>
<p>做题的时候，建议 <strong>先画树形图</strong> ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。</p>
<p>在画图的过程中思考清楚：</p>
<ul>
<li>
<p>分支如何产生；</p>
</li>
<li>
<p>题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？</p>
</li>
<li>
<p>哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结</p>
</li>
</ul>
<p>果，应该提前剪枝，剪枝的条件是什么，代码怎么写？</p>
</blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">回溯法练习</a></strong></p>
</li>
</ol>
<hr>
<h2 id="20210110">2021.01.10</h2>
<ol>
<li>
<p>枚举类 关键字enum</p>
</li>
<li>
<p>使用了带有null值得引用类型变量，instanceof操作会返回false</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">){</span>
  Integer isNull <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
  <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>isNull <span style="color:#66d9ef">instanceof</span> Integer<span style="color:#f92672">){</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;isNull is instanceof Integer&#34;</span><span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这是instanceof操作符的一个重要特性，是的对类型强制转换检查很有用</p>
<p><strong>静态方法为null调用静态方法不会抛出NullPointerException，因为静态方法使用了静态绑定。</strong></p>
</li>
</ol>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
